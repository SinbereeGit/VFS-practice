# 说明

罪过罪过~ 这个文档里面全是文字说明, 没有图片说明.

## 功能说明

1. 该模块提供一个支持 **串行多用户**, **去重存储** 的 **虚拟文件系统**, 实例化该系统需要指定 *根目录* 和 *用户标识*.
2. 可以利用该系统实现一个多用户虚拟文件系统 -- 实例化多个该系统, 它们的 *根目录* 是相同的, 但 *用户标识* 唯一.  
   > **Warning**: 但对于同一个 *根目录*, 同一时间只能有一个系统实例在运行 (这也是为什么叫 *串行多用户*).
3. 跨平台问题:
   - 支持 *Unix/Linux*、*Windows* (原则上对 *MacOS* 应该也是支持的, 但是我们没有测试) .

## 设计说明

这里的设计实在是有些稀烂, 以后还是老老实实按照 *软件工程* 的方法进行开发 (:~.

### 关于路径

#### 列表路径

参见 [_dir_tree_handler 的说明文档].

#### 内部路径

即 `_dir_tree_handler` 模块中的 列表路径 的元素以 `/` 连接的字符串.

根路径: `'/'`.

当前路径: `''` (即空字符串) .

> 注: 一个 内部路径 允许以 `/` 结尾 (不错吧~).

#### 外部路径

即和当前操作系统相关的, 非该虚拟文件系统内部的路径.

### 使用模块

内部目录树的处理: `__dir_tree_handler` 模块

文件引用计数的处理: `_utils/count_manager` 模块

文件散列值的计算: `_utils/hash_calculator` 模块

### 核心 -- *实体文件* 处理

#### *实体文件* 的 *引用计数*

增加一个 *实体文件* 的 *引用计数*, 如果出现下面的情况之一:

- 从外界导入了该文件.
- 内部复制了该文件.

减少一个 *实体文件* 的 *引用计数*, 如果出现下面的情况之一:

- 内部删除了该文件.

#### *实体文件* 的 增加 和 删除

增加一个 *实体文件*, 当 *实体文件集目录* 中没有这个文件, 如果出现下面的情况之一:

- , 从外部导入了该文件.

删除一个 *实体文件*, 如果出现下面的情况之一:

- 该文件的引用计数减为 0.

#### *实体文件* 的状态

- 它是 *纯粹无用的*, 如果它的文件名不是以规定散列值命名的.
- 它是 *无法被删除的*, 如果一个 *用户目录树文件* 中有对它的引用, 但这个文件被删除了或者被废弃了.
- 它是 *被污染的*, 如果对它的 *引用计数* 的修改不是通过该系统完成的.
- 它是 *虚假的* 或 *损坏的*, 如果它的文件名确是一个规定散列值, 但这个散列值并不等于该文件内容对应的散列值.

### 内部一致处理

#### 放在最前面

下面所说的方法 **不包括** *嵌套函数*.

#### 对方法的要求

> 遵循 *无副作用原则* (doge: 自己编的一个词).
>
> 即, 对返回值的处理不会影响到原来的对象, 对传入的参数的处理也不会影响到原来的对象.
>
> 对返回值的处理不会影响到原来的对象:
>
> ```python
> # 比如对于方法 some_method(...) -> list:
> result = some_method(...)
> # 对 result 的以下处理是安全的:
> result.dosomething(...)
> # 对 result 的以下处理是不安全的:
> result[0].dosomething(...)
> ```
>
> 对传入的参数的处理不会影响到原来的对象:
>
> ```python
> # 比如对于方法 some_method(list) -> ...:
> # 调用前, 列表 myobj 的内容是 [obj1, obj2, obj3], obj1 = [1]
> some_method(myobj)
> # 调用后, 列表 myobj 的内容仍是 [obj1, obj2, obj3], 但可能 obj1 = [2]
> ```

每个方法都应该特别注意对 **当前路径** 和 **根路径** 的处理.

所有的方法都是 **非覆盖式** 的 (这样的处理可以减少很多检查) .

除了 `__init__` 方法, 每个方法的参数中的路径只有显式指明了 outer 的才是 *外部路径*.

##### 对于 *私有方法*

路径参数 **必须** 是 *列表路径* 或 *外部路径*, 就是不能是 *内部路径* (这样做是为了处理上的方便).  
除了进行路径转换和合法性判断之类的方法 (比如 `__join_two_paths`, `__is_valid_path`).

默认被调用时传入的 *列表路径* 是 **有效的**.  
也就是说, 传入的 *列表路径* 必须满足 `__check_inner_path_validity` 为真.  
如果调用 *私有方法* 时不满足这一点, 则可能会产生错误.

##### 对于 *公有方法*

*公有方法* 在调用 *私有方法* 时, 如果要使用 *列表路径*, **必须** 先将 *内部路径* 通过 `__convert_inner_path_to_list_path` 转换成 *列表路径*.

#### 异常处理的安排

> 这里采取的原则是, 一个方法应当尽可能利用它调用的方法中的异常处理, 而不是自己再重复地检查或处理这些异常.

这里只是对几种处理情况举一些例子, 而不一一列举.

利用它调用的方法中的异常处理:

- 比如 *异常* -- "*外部路径* 包含 *根路径*", 我们放在 *私有方法* 中处理后, 在公有方法中就不用再重复检查.

虽然它调用的方法中的有这个异常处理, 但是还是要检查的情况:

- 在 `delete` 中, 我们还是对 *异常* -- "该路径是 *当前路径*" 进行了检查 (即使在它调用的方法 `_dir_tree_handler.delete` 中也有这个检查), 这是因为我们在调用这个方法之前做的一些事中是需要这个异常条件是不满足的 (在这个具体的例子中, 我们当然不希望在减少了文件的引用计数后, 在删除该结点的时候才发现这个操作是不应该做的, "what's done is done, we can only cry for our carelessness").

**上面两种情况体现了 *尽可能* 意味着什么**

#### 比较杂的约定

用 `file_id` 表示 *实体文件* 的唯一标识 (在这里也是它的文件名) .

*实体文件* 的唯一标识的生成是通过 *SHA-256* 进行的.

### 为将来实现的准备

将 `引用计数处理模块` 单独出去了, 这样方便后续将这个模块变得支持并行处理.

### 为高效实现的准备

暂无.

### 一些杂言碎语

对于同一个 *根目录* 想要多个系统实例并发运行, 这里提供一个方法作为参考 (内部外部配合处理):

- 因为这里不太好处理的主要是临界问题, 而这种临界情况在实际的情况中实际上出现的不多, 所以可以考虑一种错误容纳检测机制, 在发生错误时抛出异常, 然后让外部去处理这个异常, 这似乎是可行的.
- 幸运地是, 这里的 sqlite 貌似可以作为这个抛出异常的地方, 可以在马上的版本中试试.
- 应该还有一些东西要考虑.

[_dir_tree_handler 的说明文档]: ./_dir_tree_handler.md
